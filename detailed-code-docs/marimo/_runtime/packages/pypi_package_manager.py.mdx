---
title: "pypi_package_manager.py"
---

## High-level description

The `pypi_package_manager.py` file defines a set of classes that manage the installation of Python packages using different package managers. These classes extend a base class that provides a framework for package management, including methods for installing packages and mapping module names to package names. The file includes specific implementations for various package managers like `pip`, `micropip`, `uv`, `rye`, and `poetry`.

## Code Structure

The main symbols in the code are classes that represent different package managers. Each class inherits from `PypiPackageManager`, which in turn inherits from `CanonicalizingPackageManager`. The `PypiPackageManager` class provides a method to construct a mapping from module names to PyPI package names. Each subclass implements the `_install` method to handle the installation of packages using the respective package manager.

## References

- `module_name_to_pypi_name`: A function imported from `module_name_to_pypi_name` that provides a mapping from module names to PyPI package names.
- `CanonicalizingPackageManager`: A base class from `package_manager.py` that provides common functionality for package managers.
- `is_pyodide`: A utility function from `platform.py` to check if the code is running in a Pyodide environment.

## Symbols

### `PypiPackageManager`
#### Description
The `PypiPackageManager` class extends `CanonicalizingPackageManager` and provides a method to construct a mapping from module names to PyPI package names.

#### Inputs
None directly, but it uses the `module_name_to_pypi_name` function to construct the mapping.

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| mapping | `dict[str, str]` | A dictionary mapping module names to PyPI package names. |

#### Internal Logic
The `_construct_module_name_mapping` method returns the result of `module_name_to_pypi_name()`, which is expected to be a dictionary mapping module names to PyPI package names.

### `PipPackageManager`
#### Description
The `PipPackageManager` class is a specific implementation of `PypiPackageManager` for managing packages using `pip`.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| package | `str` | The name of the package to install. |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| success | `bool` | Returns `True` if the installation was successful, otherwise `False`. |

#### Internal Logic
The `_install` method uses the `run` method to execute the `pip install` command for the given package.

### `MicropipPackageManager`
#### Description
The `MicropipPackageManager` class is a specific implementation of `PypiPackageManager` for managing packages using `micropip`, typically in a Pyodide environment.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| package | `str` | The name of the package to install. |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| success | `bool` | Returns `True` if the installation was successful, otherwise `False`. |

#### Internal Logic
The `_install` method checks if the environment is Pyodide, then uses `micropip` to install the package. It handles exceptions to return `False` if the installation fails.

### `UvPackageManager`
#### Description
The `UvPackageManager` class is a specific implementation of `PypiPackageManager` for managing packages using the `uv` package manager.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| package | `str` | The name of the package to install. |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| success | `bool` | Returns `True` if the installation was successful, otherwise `False`. |

#### Internal Logic
The `_install` method uses the `run` method to execute the `uv pip install` command for the given package.

### `RyePackageManager`
#### Description
The `RyePackageManager` class is a specific implementation of `PypiPackageManager` for managing packages using the `rye` package manager.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| package | `str` | The name of the package to install. |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| success | `bool` | Returns `True` if the installation was successful, otherwise `False`. |

#### Internal Logic
The `_install` method uses the `run` method to execute the `rye add` command for the given package.

### `PoetryPackageManager`
#### Description
The `PoetryPackageManager` class is a specific implementation of `PypiPackageManager` for managing packages using `poetry`.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| package | `str` | The name of the package to install. |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| success | `bool` | Returns `True` if the installation was successful, otherwise `False`. |

#### Internal Logic
The `_install` method uses the `run` method to execute the `poetry add` command for the given package.

## Dependencies

| Dependency | Purpose |
|:-----------|:--------|
| `subprocess` | Used to run shell commands for package installation. |
| `shutil` | Used to check if a package manager is installed on the system. |
| `abc` | Provides the abstract base class for defining the package manager interface. |

## Error Handling

The `MicropipPackageManager` class includes error handling for the `micropip.install` method, catching `ValueError` exceptions and returning `False` if an error occurs during installation.

## Side Effects

- The `_install` methods in each package manager class execute shell commands, which can modify the system state by installing packages.
- The `MicropipPackageManager` imports `micropip` dynamically, which can affect the module state if `micropip` is not available.

## Performance Considerations

- The use of subprocesses to run package manager commands can be resource-intensive and may block the event loop if not handled asynchronously.
- The `MicropipPackageManager` is optimized for Pyodide environments, where package installation is typically lightweight and fast.

## TODOs

None present in the code.