---
title: "app.py"
---

## High-level description

The target file, `app.py`, is a Marimo application designed to provide an interactive tutorial on signal decomposition. It guides users through the process of breaking down complex signals into simpler components, allowing them to experiment with different component classes and understand their effects on signal decomposition. The application is structured as a series of interactive cells that use Marimo's UI components to facilitate user interaction and visualization.

## Code Structure

The code is organized into multiple `@app.cell` functions, each representing a distinct interactive component or step in the tutorial. These cells are executed in sequence to build the application's UI and logic. The application uses Marimo's state management and UI components extensively to create an interactive experience. The main symbols in the code are interconnected through the use of shared state and UI components, allowing for dynamic updates and user interaction.

## Symbols

### `app`
#### Description
The `app` is an instance of `marimo.App`, which serves as the main application object for the Marimo framework. It orchestrates the execution of the interactive cells and manages the application's lifecycle.

### `@app.cell`
#### Description
Each `@app.cell` decorator defines a function that represents a unit of interaction or computation within the application. These cells are executed in sequence to build the application's UI and logic.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| mo | Marimo object | Provides access to Marimo's UI components and state management. |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| output | Varies | The output of each cell varies depending on its purpose, such as UI components, state variables, or computed values. |

#### Internal Logic
The internal logic of each cell typically involves setting up UI components, managing state, and defining interactions. For example, some cells create radio buttons for selecting component classes, while others manage the state of selected components or display visualizations.

### `StickyBool`
#### Description
A helper class used to maintain a boolean state that can be set to `True` and remains `True` once set. It is used to track whether certain conditions have been met during the tutorial.

#### Inputs
None

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| value | bool | The current boolean state. |

#### Internal Logic
The class provides a `set` method to set the state to `True` and an `__bool__` method to evaluate the state as a boolean.

### `Solved`
#### Description
A class used to track the state of whether the user has "solved" the signal decomposition problem. It maintains both a current state (`now`) and a persistent state (`ever`).

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| sticky_bool | StickyBool | A `StickyBool` instance to track the persistent state. |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| ever | bool | Indicates if the problem has ever been solved. |
| now | bool | Indicates if the problem is currently solved. |

#### Internal Logic
The class initializes with a `StickyBool` to track the persistent state and provides logic to update the current state based on user actions.

## References

- `complib`: A module that provides component classes and utility functions for signal decomposition.
- `intro_problem`: A module that defines the introductory problem and provides methods for plotting and decomposing signals.
- `problems`: A module that defines various signal decomposition problems and configurations.
- `explainer`: A module that provides explanations for different component classes.

## Dependencies

| Dependency | Purpose |
|:-----------|:--------|
| `marimo` | Provides the framework for building interactive applications. |
| `gfosd` | Used for signal decomposition and component construction. |
| `numpy` | Provides numerical operations and data structures. |
| `matplotlib.pyplot` | Used for plotting and visualizing data. |

## Error Handling

The code uses Marimo's `mo.stop` method to halt execution if certain conditions are not met, such as when a problem is not defined or when a decomposition should not be computed.

## Logging

The code does not explicitly implement logging mechanisms, but it uses Marimo's UI components to provide feedback and guidance to the user.

## API/Interface Reference

The application does not expose an external API but provides an interactive interface through Marimo's UI components. Users interact with the application by selecting options, uploading data, and viewing visualizations.

## TODOs

There are no explicit TODOs or notes left in the code.