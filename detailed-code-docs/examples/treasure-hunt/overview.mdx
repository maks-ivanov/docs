---
title: "Overview"
---

## High-level description
This directory contains the code for a Treasure Hunt web application. It's a Flask-based backend with a Vue.js frontend that generates clues for a real-world treasure hunt game using GPTScript. The application allows users to input a list of locations and receive AI-generated clues for each location.

## What does it do?
The Treasure Hunt application works as follows:
1. Users access a web interface where they can input a list of locations within a city.
2. The frontend, built with Vue.js, sends this list to the Flask backend.
3. The backend uses GPTScript to generate fun and interesting clues for each location.
4. The generated clues are then sent back to the frontend and displayed to the user in a formatted, easy-to-read manner.

This application demonstrates the integration of AI-powered content generation with a web application, providing an interactive and engaging experience for users planning a treasure hunt.

## Entry points
The main entry points for this application are:

1. `app.py`: This is the Flask application that serves as the backend. It handles requests from the frontend, processes user input, and generates clues using GPTScript.

2. `templates/index.html`: This is the main HTML template for the web interface. It sets up the structure for the Vue.js application and includes necessary scripts and stylesheets.

3. `static/js/app.js`: This file contains the Vue.js application that manages the frontend logic, including user interactions and communication with the backend.

The data flow in the application is as follows:
1. User input is captured in the Vue.js frontend.
2. The frontend sends a POST request to the `/get-clues` endpoint in the Flask backend.
3. The backend processes the request, generates clues using GPTScript, and sends the response back to the frontend.
4. The frontend renders the received clues in a formatted manner.

## Key Files
1. `Dockerfile`: Defines the container environment for running the application, specifying Python 3.9 as the base image and setting up the necessary environment variables and commands.

2. `requirements.txt`: Lists the Python dependencies required for the application, including Flask and any other necessary libraries.

3. `package.json`: Specifies the Node.js dependencies, particularly the "marked" package used for Markdown parsing in the frontend.

4. `static/css/style.css`: Contains custom CSS styles for the application, ensuring a visually appealing and consistent user interface.

## Dependencies
The application relies on several key dependencies:

1. Flask (Python): Web framework for the backend application.
2. GPTScript: Used for generating clues based on user input.
3. Vue.js (JavaScript): Frontend framework for building the user interface.
4. Axios (JavaScript): HTTP client for making requests from the frontend to the backend.
5. Marked (JavaScript): Markdown parser and compiler for rendering clues.
6. Bulma (CSS): Provides the main styling for the application.

The specific versions of these dependencies are not provided in the given information, except for the "marked" package which is specified as "^12.0.1" in the `package.json` file.

## Configuration
The application uses the following configuration options:

1. Environment Variables:
   - `FLASK_APP`: Set to "app.py" in the Dockerfile, specifying the main application file.
   - `FLASK_DEBUG`: Set to "False" in the Dockerfile, disabling Flask's debug mode for production use.
   - `OPENAI_API_KEY`: Must be set up by the user to authenticate with the OpenAI API for GPTScript functionality.

2. Flask Configuration:
   - Debug mode is set to True in `app.py` for development purposes, overriding the Dockerfile setting.

3. Frontend Configuration:
   - The Marked library is configured in `app.js` to enable GitHub Flavored Markdown and smart lists.
   - Syntax highlighting is set up for code blocks using highlight.js.

To run the application, users need to set up their OpenAI API key and install the required dependencies for both Python and Node.js. The application can then be run using Flask's development server or deployed using the provided Dockerfile for a more production-ready setup.