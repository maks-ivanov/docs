---
title: "autocorrelation.py"
---

```diff
--- a/cassiopeia/tools/autocorrelation.py
+++ b/cassiopeia/tools/autocorrelation.py
@@ -1,6 +1,7 @@
 """
 Utility file for computing autocorrelation statistics on trees.
 """
+from collections import defaultdict
 from typing import Callable, List, Optional, Union
 import numpy as np
 import pandas as pd
@@ -107,3 +108,100 @@
         I = I.iloc[0, 0]
 
     return I
+
+
+def compute_geary_c(
+    tree: CassiopeiaTree,
+    meta_columns: Optional[List] = None,
+    X: Optional[pd.DataFrame] = None,
+    W: Optional[pd.DataFrame] = None,
+    inverse_weight_fn: Callable[[Union[int, float]], float] = lambda x: 1.0 / x,
+) -&gt; Union[float, pd.DataFrame]:
+    """Computes Geary's C statistic.
+
+    Using the cross-correlation between leaves as specified on the tree, compute
+    the Geary's C statistic for each of the data items specified. This will
+    only work for numerical data, and will thrown an error otherwise.
+
+    Generally, this statistic takes in a weight matrix (which can be computed
+    directly from a phylogenetic tree) and a set of numerical observations.
+    Then, the Geary's C statistic is:
+
+    C = ( (N - 1) / (2 * sum([w_i,j for all i,j])) ) * 
+        ( sum([w_i,j * (x_i - x_j) ** 2.0 for all i,j]) / 
+          sum([(x_i - x_bar) ** 2.0 for all i])
+        )
+
+    where x_bar denotes the mean of the observations.
+
+    Inspired from the tools and code used in Chaligne et al, Nature Genetics
+    2021.
+
+    The mathematical details of the statistic can be found in:
+        Geary, "The Contiguity Ratio and Statistical Mapping", The Incorporated
+        Statistician (1954)
+
+    Args:
+        tree: CassiopeiaTree
+        meta_columns: Columns in the Cassiopeia Tree :attr:cell_meta object
+            for which to compute autocorrelations
+        X: Extra data matrix for computing autocorrelations.
+        W: Phylogenetic weight matrix. If this is not specified, then the
+            weight matrix will be computed within the function.
+        inverse_weight_fn: Inverse function to apply to the weights, if the
+            weight matrix must be computed.
+
+    Returns:
+        Geary's C statistic
+    """
+
+    if X is None and meta_columns is None:
+        raise AutocorrelationError(
+            "Specify data for computing autocorrelations."
+        )
+
+    _X = None
+    if meta_columns is not None:
+        _X = tree.cell_meta[meta_columns]
+
+    if X is not None:
+        if len(np.intersect1d(tree.leaves, X.index)) != tree.n_cell:
+            raise AutocorrelationError(
+                "Specified argument X must be a dataframe with identical"
+                " indices to the leaves of the CassiopeiaTree."
+            )
+
+        _X = pd.concat([_X, X], axis=0)
+
+    # check to make sure all values are numerical
+    if not np.all(
+        _X.apply(lambda s: pd.to_numeric(s, errors="coerce").notnull().all())
+    ):
+        raise AutocorrelationError(
+            "There are some columns that are not numeric in the specified data."
+        )
+    
+    # cast to numeric
+    _X = _X.apply(lambda s: pd.to_numeric(s, errors="coerce"))
+
+    # instantiate the weight matrix if None is specified
+    if W is None:
+        W = utilities.compute_phylogenetic_weight_matrix(
+            tree, inverse=True, inverse_fn=inverse_weight_fn
+        )
+
+    # make sure that W has the correct indices
+    if len(np.intersect1d(tree.leaves, W.index)) != tree.n_cell:
+            raise AutocorrelationError(
+                "Weight matrix does not have the same leaves as the tree."
+            )
+
+    N = tree.n_cell
+
+    C = defaultdict(list)
+    for i in range(_X.shape[1]):
+        x = _X.iloc[:,i].values
+        C[_X.columns[i]] =  ((N - 1) / (2 * W.sum().sum())) * ((W * (x[:, None] - x) ** 2).sum() / ((x - x.mean()) ** 2).sum())
+
+    return pd.DataFrame.from_dict(C)

```